var documenterSearchIndex = {"docs":
[{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"EditURL = \"https://github.com/cossio/CenteredRBMs.jl/blob/master/docs/src/literate/MNIST.jl\"","category":"page"},{"location":"literate/MNIST/#MNIST","page":"MNIST","title":"MNIST","text":"","category":"section"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"We begin by importing the required packages. We load MNIST via the MLDatasets.jl package.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"using CairoMakie, Statistics\nimport MLDatasets, Flux\nimport RestrictedBoltzmannMachines as RBMs\nimport CenteredRBMs\nusing RestrictedBoltzmannMachines: BinaryRBM\nusing CenteredRBMs: BinaryCenteredRBM\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Useful function to plot MNIST digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"\"\"\"\n    imggrid(A)\n\nGiven a four dimensional tensor `A` of size `(width, height, ncols, nrows)`\ncontaining `width x height` images in a grid of `nrows x ncols`, this returns\na matrix of size `(width * ncols, height * nrows)`, that can be plotted in a heatmap\nto display all images.\n\"\"\"\nfunction imggrid(A::AbstractArray{<:Any,4})\n    reshape(permutedims(A, (1,3,2,4)), size(A,1)*size(A,3), size(A,2)*size(A,4))\nend","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Let's visualize some random digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nrows, ncols = 10, 15\nfig = CairoMakie.Figure(resolution=(40ncols, 40nrows))\nax = CairoMakie.Axis(fig[1,1], yreversed=true)\ndigits = MLDatasets.MNIST.traintensor()\ndigits = digits[:,:,rand(1:size(digits,3), nrows * ncols)]\ndigits = reshape(digits, 28, 28, ncols, nrows)\nCairoMakie.image!(ax, imggrid(digits), colorrange=(1,0))\nCairoMakie.hidedecorations!(ax)\nCairoMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now load the full dataset.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"train_x, train_y = MLDatasets.MNIST.traindata()\ntests_x, tests_y = MLDatasets.MNIST.testdata()\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"train_x, tests_x contain the digit images, while train_y, tests_y contain the labels. We will train an RBM with binary (0,1) visible and hidden units. Therefore we binarize the data first. In addition, we restrict our attention to 0,1 digits only, so that training and so on are faster.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Float = Float32\nselected_digits = (0, 1)\ntrain_x = Array{Float}(train_x[:, :, train_y .∈ Ref(selected_digits)] .> 0.5)\ntests_x = Array{Float}(tests_x[:, :, tests_y .∈ Ref(selected_digits)] .> 0.5)\ntrain_y = train_y[train_y .∈ Ref(selected_digits)]\ntests_y = tests_y[tests_y .∈ Ref(selected_digits)]\ntrain_nsamples = length(train_y)\ntests_nsamples = length(tests_y)\n(train_nsamples, tests_nsamples)","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"The original binarized train_x and tests_x are BitArrays. Though convenient in terms of memory space, these are very slow in linear algebra. Since we frequently multiply data configurations times the weights of our RBM, we want to speed this up. So we convert to floats, which have much faster matrix multiplies thanks to BLAS. We will use Float32 here. To hit BLAS, this must be consistent with the types we use in the parameters of the RBM below.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot some examples of the binarized data.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nrows, ncols = 10, 15\nfig = CairoMakie.Figure(resolution=(40ncols, 40nrows))\nax = CairoMakie.Axis(fig[1,1], yreversed=true)\ndigits = reshape(train_x[:, :, rand(1:size(train_x,3), nrows * ncols)], 28, 28, ncols, nrows)\nCairoMakie.image!(ax, imggrid(digits), colorrange=(1,0))\nCairoMakie.hidedecorations!(ax)\nCairoMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Initialize and train a centered RBM Notice how we pass the Float type, to set the parameter type of the layers and weights in the RBM.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"rbm = BinaryRBM(zeros(Float,28,28), zeros(Float,400), zeros(Float,28,28,400))\nRBMs.initialize!(rbm, train_x)\ncentered_rbm = CenteredRBMs.center(rbm)\nCenteredRBMs.center_from_data!(centered_rbm, train_x)\n@time history = RBMs.pcd!(centered_rbm, train_x; epochs=500, batchsize=256)\nrbm = CenteredRBMs.uncenter(centered_rbm)\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot of log-pseudolikelihood during learning. Note that this shows the pseudolikelihood of the train data.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"CairoMakie.lines(get(history, :lpl)...)","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now let's generate some random RBM samples. First, we select random data digits to be initial conditions for the Gibbs sampling, and let's plot them.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nrows, ncols = 10, 15\nfantasy_x = train_x[:, :, rand(1:train_nsamples, nrows * ncols)]\nfig = CairoMakie.Figure(resolution=(40ncols, 40nrows))\nax = CairoMakie.Axis(fig[1,1], yreversed=true)\nCairoMakie.image!(ax, imggrid(reshape(fantasy_x, 28, 28, ncols, nrows)), colorrange=(1,0))\nCairoMakie.hidedecorations!(ax)\nCairoMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now we do the Gibbs sampling to generate the RBM digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"@elapsed fantasy_x .= RBMs.sample_v_from_v(rbm, fantasy_x; steps=10000)","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot the resulting samples.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = CairoMakie.Figure(resolution=(40ncols, 40nrows))\nax = CairoMakie.Axis(fig[1,1], yreversed=true)\nCairoMakie.image!(ax, imggrid(reshape(fantasy_x, 28, 28, ncols, nrows)), colorrange=(1,0))\nCairoMakie.hidedecorations!(ax)\nCairoMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CenteredRBMs]","category":"page"},{"location":"reference/#CenteredRBMs.CenteredRBM-Tuple{RestrictedBoltzmannMachines.AbstractLayer, RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"CenteredRBMs.CenteredRBM","text":"CenteredRBM(visible, hidden, w)\n\nCreates a centered RBM, with offsets initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.CenteredRBM-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray, AbstractArray}","page":"Reference","title":"CenteredRBMs.CenteredRBM","text":"CenteredRBM(rbm::RBM, offset_v, offset_h)\n\nCreates a CenteredRBM with offsets offset_v (visible) and offset_h (hidden). The resulting model is not equivalent to the original rbm (unless offsetv = 0 and offseth = 0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.RBM-Tuple{CenteredRBMs.CenteredRBM}","page":"Reference","title":"RestrictedBoltzmannMachines.RBM","text":"RBM(centered_rbm::CenteredRBM)\n\nReturns an (uncentered) RBM which neglects the offsets of centered_rbm. The resulting model is not equivalent to the original centered_rbm. To construct an equivalent model, use the function uncenter(centered_rbm) instead (see uncenter).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.BinaryCenteredRBM-NTuple{5, AbstractArray}","page":"Reference","title":"CenteredRBMs.BinaryCenteredRBM","text":"BinaryCenteredRBM(a, b, w, offset_v = 0, offset_h = 0)\n\nConstruct a centered RBM with binary visible and hidden units\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.center!-Tuple{CenteredRBMs.CenteredRBM, AbstractArray, AbstractArray}","page":"Reference","title":"CenteredRBMs.center!","text":"center!(centered_rbm, offset_v = 0, offset_h = 0)\n\nTransforms the offsets of centered_rbm. The transformed model is equivalent to the original one (energies differ by a constant).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.center-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray, AbstractArray}","page":"Reference","title":"CenteredRBMs.center","text":"center(rbm::RBM, offset_v = 0, offset_h = 0)\n\nConstructs a CenteredRBM equivalent to the given rbm. The energies assigned by the two models differ by a constant amount,\n\nE(vh) - E_c(vh) = sum_imuw_imulambda_ilambda_mu\n\nwhere E(vh) is the energy assigned by the original rbm, and E_c(vh) is the energy assigned by the returned CenteredRBM.\n\nThis is the inverse operation of uncenter.\n\nTo construct a CenteredRBM that simply includes these offsets, call CenteredRBM(rbm, offset_v, offset_h) instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.pcdc!-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"CenteredRBMs.pcdc!","text":"pcdc!(rbm, data)\n\nTrains the RBM on data using Persistent Contrastive divergence, with centered gradients. See:\n\nJ. Melchior, A. Fischer, and L. Wiskott. JMLR 17.1 (2016): 3387-3447. http://jmlr.org/papers/v17/14-237.html\n\n\n\n\n\n","category":"method"},{"location":"reference/#CenteredRBMs.shift_fields!","page":"Reference","title":"CenteredRBMs.shift_fields!","text":"shift_fields!(layer, offset)\n\nAdds offset to the layer fields.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CenteredRBMs.uncenter-Tuple{CenteredRBMs.CenteredRBM}","page":"Reference","title":"CenteredRBMs.uncenter","text":"uncenter(centered_rbm::CenteredRBM)\n\nConstructs an RBM equivalent to the given CenteredRBM. The energies assigned by the two models differ by a constant amount,\n\nE(vh) - E_c(vh) = sum_imuw_imulambda_ilambda_mu\n\nwhere E_c(vh) is the energy assigned by centered_rbm and E(vh) is the energy assigned by the RBM constructed by this method.\n\nThis is the inverse operation of center.\n\nTo construct an RBM that simply neglects the offsets, call RBM(centered_rbm) instead.\n\n\n\n\n\n","category":"method"},{"location":"#CenteredRBMs.jl-Documentation","page":"Home","title":"CenteredRBMs.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package to train and simulate centered Restricted Boltzmann Machines. See http://jmlr.org/papers/v17/14-237.html for the definition of centered.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package does not export any symbols.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the functions have a helpful docstring. See Reference section.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not registered. Install with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/cossio/CenteredRBMs.jl\")","category":"page"},{"location":"#Related","page":"Home","title":"Related","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is based on the RestrictedBoltzmannMachines Julia package, which defines the RBM and layer types. We refer to RestrictedBoltzmannMachines by the shorter name RBMs, as if it were imported by the line","category":"page"},{"location":"","page":"Home","title":"Home","text":"import RestrictedBoltzmannMachines as RBMs","category":"page"}]
}
